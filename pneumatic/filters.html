<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Filters &mdash; Pneumatic.IO 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Pneumatic.IO 0.1 documentation" href="index.html" />
    <link rel="next" title="Testing" href="testing.html" />
    <link rel="prev" title="Current State" href="overview.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="testing.html" title="Testing"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="overview.html" title="Current State"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pneumatic.IO 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="filters">
<h1>Filters<a class="headerlink" href="#filters" title="Permalink to this headline">¶</a></h1>
<p>Filters are where the action is. Filters perform the processing in a job. There are filters that perform basic IO with files, databases, RESTful end points, etc. There are also filters for joining data sources, transforming it, converting data types, etc.</p>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="filter-reference">
<h2>Filter Reference<a class="headerlink" href="#filter-reference" title="Permalink to this headline">¶</a></h2>
<p>This section provides a reference for the available filter types.</p>
<div class="section" id="aggregator">
<h3>Aggregator<a class="headerlink" href="#aggregator" title="Permalink to this headline">¶</a></h3>
<p>The aggregator filter has a single input pipe. It also has a single output pipe: the aggregator output to which the aggregator&#8217;s function is applied.</p>
<p>A single record is written to the after all input records have been processed from the aggregator&#8217;s input.</p>
<p>Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;input&quot; /&gt;
&lt;etl:pipe id=&quot;output&quot; /&gt;
&lt;etl:pipe id=&quot;aggregatorOutput&quot; /&gt;
&lt;etl:aggregator id=&quot;priceAggregator&quot; name=&quot;Price Aggregator&quot;&gt;
        &lt;etl:input ref=&quot;input&quot; /&gt;
        &lt;etl:inputSchema ref=&quot;inputSchema&quot; /&gt;
        &lt;etl:output ref=&quot;aggregatorOutput&quot; /&gt;
        &lt;etl:outputSchema ref=&quot;aggregatorSchema&quot; /&gt;
        &lt;etl:function&gt;
                &lt;etl:sum&gt;
                        &lt;etl:in&gt;
                                &lt;etl:column name=&quot;Price&quot; type=&quot;decimal&quot; /&gt;
                        &lt;/etl:in&gt;
                        &lt;etl:out&gt;
                                &lt;etl:column name=&quot;Total Price&quot; type=&quot;decimal&quot; /&gt;
                        &lt;/etl:out&gt;
                &lt;/etl:sum&gt;
        &lt;/etl:function&gt;
&lt;/etl:aggregator&gt;
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">etl:function</span></code> element is the heart of the aggregator. In this case, we have a &#8220;sum&#8221; function (<code class="docutils literal"><span class="pre">etl:sum</span></code>). The sum function sums the input selected by the <code class="docutils literal"><span class="pre">etl:in</span></code> column and writes it to the output in the column defined in <code class="docutils literal"><span class="pre">etl:out</span></code>.</p>
<p>The available functions are:</p>
<ul class="simple">
<li>average</li>
<li>count</li>
<li>sum</li>
</ul>
<p>That&#8217;s not very many functions, but the aggregator may be extended with any function you like using a Spring Bean:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:aggregator id=&quot;aggregator2&quot; name=&quot;Test Aggregator 2&quot;&gt;
        &lt;etl:input ref=&quot;input&quot; /&gt;
        &lt;etl:inputSchema ref=&quot;inputSchema&quot; /&gt;
        &lt;etl:output ref=&quot;aggregatorOutput&quot; /&gt;
        &lt;etl:outputSchema ref=&quot;aggregatorSchema&quot; /&gt;
        &lt;etl:function&gt;
                &lt;bean class=&quot;com.surgingsystems.etl.filter.function.SumFunction&quot;&gt;
                        &lt;property name=&quot;inputColumnDefinition&quot;&gt;
                                &lt;etl:column name=&quot;Price&quot; type=&quot;decimal&quot; /&gt;
                        &lt;/property&gt;
                        &lt;property name=&quot;outputColumnDefinition&quot;&gt;
                                &lt;etl:column name=&quot;Total Price&quot; type=&quot;decimal&quot; /&gt;
                        &lt;/property&gt;
                &lt;/bean&gt;
        &lt;/etl:function&gt;
&lt;/etl:aggregator&gt;
</pre></div>
</div>
<p>In this case, we are referencing the underlying Java class (<code class="docutils literal"><span class="pre">SumFunction</span></code>). Any function that implements the internal Function interface may be used. That interface is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">com</span><span class="o">.</span><span class="n">surgingsystems</span><span class="o">.</span><span class="n">etl</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">Function</span>
</pre></div>
</div>
</div>
<div class="section" id="copy">
<h3>Copy<a class="headerlink" href="#copy" title="Permalink to this headline">¶</a></h3>
<p>The copy filter has a single input pipe. It may have any number of output pipes. Each record on the input is written to each output:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;copyOutput1&quot; /&gt;
&lt;etl:pipe id=&quot;copyOutput2&quot; /&gt;
&lt;etl:copy id=&quot;copy&quot; name=&quot;Test Copy&quot;&gt;
        &lt;etl:input ref=&quot;fileReaderOutput&quot; /&gt;
        &lt;etl:output ref=&quot;copyOutput1&quot; /&gt;
        &lt;etl:output ref=&quot;copyOutput2&quot; /&gt;
&lt;/etl:copy&gt;
</pre></div>
</div>
<p>In this example, the records from the input (<code class="docutils literal"><span class="pre">ref=&quot;fileReaderOutput&quot;</span></code>) are sent, unaltered, to both outputs (<code class="docutils literal"><span class="pre">ref=&quot;copyOutput1&quot;</span></code>, <code class="docutils literal"><span class="pre">ref=&quot;copyOutput2&quot;</span></code>).</p>
</div>
<div class="section" id="database-lookup">
<h3>Database Lookup<a class="headerlink" href="#database-lookup" title="Permalink to this headline">¶</a></h3>
<p>The database lookup filter enables lookups to a database based on its single input. The input and lookup results may be combined for its single output.</p>
<p>The following are the key elements of the database lookup filter:</p>
<ol class="arabic simple">
<li>dataSource - The DataSource that provides connections to the database that provides the lookup data.</li>
<li>outputSchema - This is the schema that defines the output records. The filter uses the column definitions on this schema to select values from either input record values or the results of the lookup. The selection is based on the names of the inputs.</li>
<li>lookup - The lookup element composes the SQL for the lookup and its parameters.  The parameters use SpEL and may reference the input record (inputRecord) as a variable.</li>
</ol>
<p>It is important to avoid name collisions to ensure the results are as expected. Use aliasing on the select statement if needed to ensure those columns do not conflict with those on the input schema. Alternatively, use a mapper filter to change the schema of the input before it comes into this filter.</p>
<p>Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;databaseLookupOutput&quot; /&gt;
&lt;etl:databaseLookup id=&quot;databaseLookup&quot; name=&quot;Database Lookup&quot;&gt;
        &lt;etl:input ref=&quot;mapperOutput&quot; /&gt;
        &lt;etl:inputSchema ref=&quot;mapperMtbSchema&quot; /&gt;
        &lt;etl:output ref=&quot;databaseLookupOutput&quot; /&gt;
        &lt;etl:outputSchema ref=&quot;lookupSchema&quot; /&gt;
        &lt;etl:dataSource ref=&quot;dataSource&quot; /&gt;
        &lt;etl:lookup&gt;
                &lt;etl:sql&gt;
                        select year, cost from mtb where name = ?
                &lt;/etl:sql&gt;
                &lt;etl:parameter value=&quot;#inputRecord.name&quot; /&gt;
        &lt;/etl:lookup&gt;
&lt;/etl:databaseLookup&gt;
</pre></div>
</div>
<p>The data source reference (<code class="docutils literal"><span class="pre">id=&quot;dataSource&quot;</span></code>) is an object of type <code class="docutils literal"><span class="pre">javax.sql.DataSource</span></code>.  It might be defined like this:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;jdbc:embedded-database id=&quot;dataSource&quot; type=&quot;HSQL&quot;&gt;
        &lt;jdbc:script location=&quot;classpath:db-schema.sql&quot; /&gt;
        &lt;jdbc:script location=&quot;classpath:db-test-data.sql&quot; /&gt;
&lt;/jdbc:embedded-database&gt;
</pre></div>
</div>
<p>The lookup element contains the SQL to use for the lookup and any parameters it might have. Parameters are identified by a question mark. The values are specified by the parameter tag and filled in order.</p>
<p>The parameters tag may use expressions. Variables available in the expression include the input record (inputRecord) and the job parameters (job).</p>
</div>
<div class="section" id="database-reader">
<h3>Database Reader<a class="headerlink" href="#database-reader" title="Permalink to this headline">¶</a></h3>
<p>A database reader reads records from a database identified by a data source. A SQL select statement is used to select the desired records. The records are written to the output pipe.</p>
<p>Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;databaseReaderOutput&quot; /&gt;
&lt;etl:databaseReader id=&quot;databaseReader&quot; name=&quot;Database Reader&quot;&gt;
        &lt;etl:output ref=&quot;databaseReaderOutput&quot; /&gt;
        &lt;etl:outputSchema ref=&quot;sqlSelectSchema&quot; /&gt;
        &lt;etl:dataSource ref=&quot;dataSource&quot; /&gt;
        &lt;etl:select&gt;
                &lt;etl:sql&gt;
                        select * from mtb where name = ? and year = ?
                &lt;/etl:sql&gt;
                &lt;etl:parameter value=&quot;#job.name&quot; /&gt;
                &lt;etl:parameter value=&quot;#job.model_year&quot; /&gt;
        &lt;/etl:select&gt;
        &lt;etl:rejection&gt;
                &lt;output ref=&quot;databaseReaderRejectionOutput&quot; /&gt;
        &lt;/etl:rejection&gt;
&lt;/etl:databaseReader&gt;
</pre></div>
</div>
<p>The output is given by <code class="docutils literal"><span class="pre">ref=&quot;databaseReaderOutput&quot;</span></code>.</p>
<p>The output schema (<code class="docutils literal"><span class="pre">ref=&quot;sqlSelectSchema&quot;</span></code>) is used to define the output records. Columns from the select statement that match the names of the columns in the output schema are used to provide the values to the output record.</p>
<p>The select element (<code class="docutils literal"><span class="pre">etl:select</span></code>) specifies the select statement (<code class="docutils literal"><span class="pre">etl:sql</span></code>) and any parameters. The parameters are optional. Job parameters may be used to provide values to the SQL parameters.</p>
<p>The optional rejection element (<code class="docutils literal"><span class="pre">etl:rejection</span></code>) defines the behavior for rejecting records. If a record does not comply with the output schema, in this case it is sent to another pipe, <code class="docutils literal"><span class="pre">ref=&quot;databaseReaderRejectionOutput&quot;</span></code>. The default is to log the record, which can also be specified explicitly:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:rejection&gt;
        &lt;log level=&quot;WARN&quot; name=&quot;REJECTION&quot; /&gt;
&lt;/etl:rejection&gt;
</pre></div>
</div>
<p>Here, the <code class="docutils literal"><span class="pre">level</span></code> is a <a class="reference external" href="https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/Level.html">Log4J level</a>, with all those levels being available.  The <code class="docutils literal"><span class="pre">name</span></code> is the name of the logger, basically categorizing the log statement.</p>
</div>
<div class="section" id="database-writer">
<h3>Database Writer<a class="headerlink" href="#database-writer" title="Permalink to this headline">¶</a></h3>
<p>The database writer writes records from its input pipe to a database table. In its simplest form, the table name is supplied and the records are written directly to the table.  Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;fileReaderOutput&quot; /&gt;
&lt;etl:databaseWriter id=&quot;databaseWriter&quot; name=&quot;Database Writer&quot;&gt;
        &lt;etl:input ref=&quot;fileReaderOutput&quot; /&gt;
        &lt;etl:inputSchema ref=&quot;mtbSchema&quot; /&gt;
        &lt;etl:dataSource ref=&quot;dataSource&quot; /&gt;
        &lt;etl:insertInto table-name=&quot;mtb&quot; /&gt;
&lt;/etl:databaseWriter&gt;
</pre></div>
</div>
<p>The input is required (<code class="docutils literal"><span class="pre">ref=&quot;fileReaderOutput&quot;</span></code>), as is the input schema (<code class="docutils literal"><span class="pre">ref=&quot;mtbSchema&quot;</span></code>). The data source provides the filter with database connections (<code class="docutils literal"><span class="pre">ref=&quot;dataSource&quot;</span></code>).  Finally, the <code class="docutils literal"><span class="pre">insertInto</span></code> element provides the name of the table into which the records are inserted (<code class="docutils literal"><span class="pre">etl:insertInto</span> <span class="pre">table-name=&quot;mtb&quot;</span></code>).</p>
<p>The database writer has a second form for updates.  The following is an example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;fileReaderOutput&quot; /&gt;
&lt;etl:databaseWriter id=&quot;databaseWriter&quot; name=&quot;Database Writer&quot;&gt;
        &lt;etl:input ref=&quot;fileReaderOutput&quot; /&gt;
        &lt;etl:inputSchema ref=&quot;mtbSchema&quot; /&gt;
        &lt;etl:dataSource ref=&quot;dataSource&quot; /&gt;
        &lt;etl:updateWith&gt;
                &lt;etl:sql&gt;
                        update mtb set year = ?, cost = ? where name = ?
                &lt;/etl:sql&gt;
                &lt;etl:parameter value=&quot;#inputRecord.year&quot; /&gt;
                &lt;etl:parameter value=&quot;#inputRecord.cost&quot; /&gt;
                &lt;etl:parameter value=&quot;#inputRecord.name&quot; /&gt;
        &lt;/etl:updateWith&gt;
&lt;/etl:databaseWriter&gt;
</pre></div>
</div>
<p>The difference is the <code class="docutils literal"><span class="pre">etl:updateWith</span></code> element replaces the <code class="docutils literal"><span class="pre">etl:insertInto</span></code> element. This element is a bit more complex, requiring a SQL statement be specified. The question marks in the SQL statement are parameter markers. They are supplied by the parameter elements (<code class="docutils literal"><span class="pre">etl:parameter</span></code>) in the order specified. The value of each parameter may be a constant or an SpEL expression.</p>
<p>The variable <code class="docutils literal"><span class="pre">inputRecord</span></code> may be used to refer to the input record being processed. The columns on the input record may appear after a period or inside brackets.  The first example below refers to the <code class="docutils literal"><span class="pre">year</span></code> column on the input record. The second uses the brackets syntax to refer to the <code class="docutils literal"><span class="pre">name</span></code> column:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:parameter value=&quot;#inputRecord.year&quot; /&gt;

&lt;etl:parameter value=&quot;#inputRecord[&#39;name&#39;]&quot; /&gt;
</pre></div>
</div>
<p>The second syntax is useful for referring to columns that have spaces in the name:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:parameter value=&quot;#inputRecord[&#39;Column Name with Spaces&#39;]&quot; /&gt;
</pre></div>
</div>
</div>
<div class="section" id="file-reader">
<h3>File Reader<a class="headerlink" href="#file-reader" title="Permalink to this headline">¶</a></h3>
<p>The file reader reads records from a file and writes them to its output. Records are read using a CSV format. A schema is required to define the records. Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;fileReaderOutput&quot; /&gt;
&lt;etl:fileReader id=&quot;fileReader&quot; name=&quot;File Reader&quot;&gt;
        &lt;etl:fileResource location=&quot;classpath:data/mtb.txt&quot; /&gt;
        &lt;etl:output ref=&quot;fileReaderOutput&quot; /&gt;
        &lt;etl:outputSchema ref=&quot;mtbSchema&quot; /&gt;
&lt;/etl:fileReader&gt;
</pre></div>
</div>
<p>The file reader reads from the file given by its location (<code class="docutils literal"><span class="pre">location=&quot;classpath:data/mtb.txt&quot;</span></code>). Alternatively, a job argument may be used to specify the file location:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:fileResource locationExpression=&quot;#job.file&quot; /&gt;
</pre></div>
</div>
<p>The records read from the file are put on the output pipe (<code class="docutils literal"><span class="pre">ref=&quot;fileReaderOutput&quot;</span></code>). The records are constructed according to the supplied schema (<code class="docutils literal"><span class="pre">ref=&quot;mtbSchema&quot;</span></code>).</p>
</div>
<div class="section" id="file-writer">
<h3>File Writer<a class="headerlink" href="#file-writer" title="Permalink to this headline">¶</a></h3>
<p>The file writer reads records from its input and writes them to a file. The input schema in optional. If supplied, records will be validated against the schema and rejected if they don&#8217;t conform. Records are written in a CSV format. Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;fileReaderOutput&quot; /&gt;
&lt;etl:fileWriter id=&quot;fileWriter&quot; name=&quot;File Writer&quot;&gt;
        &lt;etl:fileResource location=&quot;file:output/output1.txt&quot; /&gt;
        &lt;etl:input ref=&quot;fileReaderOutput&quot; /&gt;
        &lt;etl:inputSchema ref=&quot;mtbSchema&quot; /&gt;
&lt;/etl:fileWriter&gt;
</pre></div>
</div>
<p>The file location (<code class="docutils literal"><span class="pre">location=&quot;file:output/output1.txt&quot;</span></code>) uses the <a class="reference external" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/resources.html">Spring resource syntax</a>. Alternatively, a job parameter may be used to supply the file location:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:fileResource locationExpression=&quot;#job.file&quot; /&gt;
</pre></div>
</div>
</div>
<div class="section" id="funnel">
<h3>Funnel<a class="headerlink" href="#funnel" title="Permalink to this headline">¶</a></h3>
<p>The funnel is a simple filter that combines its inputs into a single output, like a reverse copy filter. The funnel accepts any number of inputs and a single output. No schema is provided. Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;input1&quot; /&gt;
&lt;etl:pipe id=&quot;input2&quot; /&gt;
&lt;etl:pipe id=&quot;output&quot; /&gt;
&lt;etl:funnel id=&quot;funnel&quot; name=&quot;Funnel&quot;&gt;
        &lt;etl:input ref=&quot;input1&quot; /&gt;
        &lt;etl:input ref=&quot;input2&quot; /&gt;
        &lt;etl:output ref=&quot;output&quot; /&gt;
&lt;/etl:funnel&gt;
</pre></div>
</div>
<p>Each input (e.g, <code class="docutils literal"><span class="pre">etl:input</span> <span class="pre">ref=&quot;input1&quot;</span></code>) is read in turn and the record read from that input written to the output (<code class="docutils literal"><span class="pre">ref=&quot;output&quot;</span></code>). No ordering of the inputs to the output is guaranteed. If one of the inputs is empty, or no record is immediately available, the funnel will move to the next input. Each input is continuously read until it is closed. The funnel may process its records &#8220;slowly&#8221; if any of the inputs has no record available but is not closed. This is due to the read &#8220;timing out&#8221;. If the input is closed, there is no delay.</p>
</div>
<div class="section" id="join">
<h3>Join<a class="headerlink" href="#join" title="Permalink to this headline">¶</a></h3>
<p>The join filter joins two inputs based on a comparison of the records in the inputs. The inputs must be sorted according to the join (<code class="docutils literal"><span class="pre">etl:comparator</span></code>) criteria prior to use in the join filter. This means either using a sort filter or otherwise ensuring the inputs are sorted. The sort criteria must be the same as the join criteria. Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;innerJoinOutput&quot; /&gt;
&lt;etl:join id=&quot;innerJoinFilter&quot; name=&quot;Inner Join&quot;&gt;
        &lt;etl:leftInput ref=&quot;joinInput1&quot; /&gt;
        &lt;etl:rightInput ref=&quot;joinInput2&quot; /&gt;
        &lt;etl:output ref=&quot;innerJoinOutput&quot; /&gt;
        &lt;etl:outputSchema ref=&quot;inputSchema&quot; /&gt;
        &lt;etl:comparator&gt;
                &lt;etl:column name=&quot;Name&quot; type=&quot;string&quot; /&gt;
        &lt;/etl:comparator&gt;
&lt;/etl:join&gt;
</pre></div>
</div>
<p>As stated, the two inputs (<code class="docutils literal"><span class="pre">etl:leftInput</span> <span class="pre">ref=&quot;joinInput1&quot;</span></code> and <code class="docutils literal"><span class="pre">etl:rightInput</span> <span class="pre">ref=&quot;joinInput2&quot;</span></code>) must be sorted using the same ordering as the <code class="docutils literal"><span class="pre">comparator</span></code>. In this case, the inputs must be sorted by the <code class="docutils literal"><span class="pre">Name</span></code> column of the inputs.</p>
<p>The comparator is used to join the records based on the column provided. The default comparator only accepts a single column for the comparison. A single output record is created from the joined records. The output schema (<code class="docutils literal"><span class="pre">ref=&quot;inputSchema&quot;</span></code>) is used to select the columns from the input records. If there is no record in the <code class="docutils literal"><span class="pre">rightInput</span></code> that matches the current record in the <code class="docutils literal"><span class="pre">leftInput</span></code> no output record is written.</p>
<p>The join filter has a second form:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;outerJoinOutput&quot; /&gt;
&lt;etl:join id=&quot;outerJoinFilter&quot; name=&quot;Outer Join&quot;&gt;
        &lt;etl:leftInput ref=&quot;joinInput1&quot; /&gt;
        &lt;etl:rightInput ref=&quot;joinInput2&quot; /&gt;
        &lt;etl:output ref=&quot;outerJoinOutput&quot; /&gt;
        &lt;etl:outputSchema ref=&quot;inputSchema&quot; /&gt;
        &lt;etl:comparator&gt;
                &lt;etl:column name=&quot;Name&quot; type=&quot;string&quot; /&gt;
        &lt;/etl:comparator&gt;
        &lt;etl:leftOuterJoin /&gt;
&lt;/etl:join&gt;
</pre></div>
</div>
<p>The difference is the <code class="docutils literal"><span class="pre">etl:leftOuterJoin</span></code> element. With this element, if there is no record in the <code class="docutils literal"><span class="pre">rightInput</span></code> that matches a record in the <code class="docutils literal"><span class="pre">leftInput</span></code>, the output record is still created and sent to the output.</p>
<p>The join filter may be extended for other forms of comparison. Creating your own comparator may require some pramming and uses the Spring bean syntax. Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:join id=&quot;innerJoinWithCustomComparator&quot; name=&quot;Inner Join with Custom Comparator&quot;&gt;
        &lt;etl:leftInput ref=&quot;input1&quot; /&gt;
        &lt;etl:rightInput ref=&quot;input2&quot; /&gt;
        &lt;etl:output ref=&quot;output&quot; /&gt;
        &lt;etl:outputSchema ref=&quot;inputSchema&quot; /&gt;
        &lt;etl:comparator&gt;
                &lt;bean class=&quot;com.surgingsystems.etl.filter.JoinFilterTest.TwoColumnComparator&quot;&gt;
                        &lt;property name=&quot;columns&quot;&gt;
                                &lt;list&gt;
                                        &lt;etl:column name=&quot;Name&quot; type=&quot;string&quot; /&gt;
                                        &lt;etl:column name=&quot;Count&quot; type=&quot;integer&quot; /&gt;
                                &lt;/list&gt;
                        &lt;/property&gt;
                &lt;/bean&gt;
        &lt;/etl:comparator&gt;
&lt;/etl:join&gt;
</pre></div>
</div>
<p>Here, the comparator is provided by a Spring Bean with the given class:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;bean class=&quot;com.surgingsystems.etl.filter.JoinFilterTest.TwoColumnComparator&quot;&gt;
</pre></div>
</div>
<p>The rest of the bean definition is specific to the class itsef, but note that Pneumatic elements may be used in defining the bean:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;list&gt;
        &lt;etl:column name=&quot;Name&quot; type=&quot;string&quot; /&gt;
        &lt;etl:column name=&quot;Count&quot; type=&quot;integer&quot; /&gt;
&lt;/list&gt;
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">etl:column</span></code> elements are the same elements used to define schemas in Pneumatic.</p>
</div>
<div class="section" id="mapper">
<h3>Mapper<a class="headerlink" href="#mapper" title="Permalink to this headline">¶</a></h3>
<p>The mapper translates records that conform to an input schema to records that conform to an output schema. In its simplest form, the output schema provides enough information to perform the mapping. Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:schema id=&quot;giantBikesSchema&quot; name=&quot;Giant Bikes Schema&quot;&gt;
        &lt;etl:column name=&quot;name&quot; type=&quot;string&quot; /&gt;
        &lt;etl:column name=&quot;bike_number&quot; type=&quot;integer&quot; /&gt;
        &lt;etl:column name=&quot;year&quot; type=&quot;integer&quot; /&gt;
        &lt;etl:column name=&quot;cost&quot; type=&quot;decimal&quot; /&gt;
&lt;/etl:schema&gt;

&lt;etl:schema id=&quot;mtbSchema&quot; name=&quot;MTB Schema&quot;&gt;
        &lt;etl:column name=&quot;name&quot; type=&quot;string&quot; /&gt;
        &lt;etl:column name=&quot;bike_number&quot; type=&quot;string&quot; /&gt;
        &lt;etl:column name=&quot;year&quot; type=&quot;integer&quot; /&gt;
&lt;/etl:schema&gt;

&lt;etl:pipe id=&quot;input&quot; /&gt;
&lt;etl:pipe id=&quot;mapperOutput&quot; /&gt;
&lt;etl:mapper id=&quot;simpleMapper&quot; name=&quot;Simple Mapper&quot;&gt;
        &lt;etl:input ref=&quot;input&quot; /&gt;
        &lt;etl:inputSchema ref=&quot;giantBikesSchema&quot; /&gt;
        &lt;etl:output ref=&quot;mapperOutput&quot; /&gt;
        &lt;etl:outputSchema ref=&quot;mtbSchema&quot; /&gt;
&lt;/etl:mapper&gt;
</pre></div>
</div>
<p>The mapper filter (<code class="docutils literal"><span class="pre">mapper</span> <span class="pre">id=&quot;simpleMapper&quot;</span></code>) uses the output schema (<code class="docutils literal"><span class="pre">ref=&quot;mtbSchema&quot;</span></code>) to choose columns from the input records. The columns are chosen by name. In this example, the input has four columns available and three are selected for output: <code class="docutils literal"><span class="pre">name</span></code>, <code class="docutils literal"><span class="pre">bike_number</span></code> and <code class="docutils literal"><span class="pre">year</span></code>.</p>
<p>Also note that the type of the <code class="docutils literal"><span class="pre">bike_number</span></code> column is changed from integer to string. The mapper is able to make reasonable type conversions automatically: integer and decimal to string and integer to decimal.</p>
<p>More complicated translations are also supported as shown in the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:schema id=&quot;giantBikesSchema&quot; name=&quot;Giant Bikes Schema&quot;&gt;
        &lt;etl:column name=&quot;name&quot; type=&quot;string&quot; /&gt;
        &lt;etl:column name=&quot;bike_number&quot; type=&quot;integer&quot; /&gt;
        &lt;etl:column name=&quot;year&quot; type=&quot;integer&quot; /&gt;
        &lt;etl:column name=&quot;cost&quot; type=&quot;decimal&quot; /&gt;
&lt;/etl:schema&gt;

&lt;etl:schema id=&quot;mtbSchema&quot; name=&quot;MTB Schema&quot;&gt;
        &lt;etl:column name=&quot;model_name&quot; type=&quot;string&quot; /&gt;
        &lt;etl:column name=&quot;model_number&quot; type=&quot;string&quot; /&gt;
        &lt;etl:column name=&quot;model_year&quot; type=&quot;integer&quot; /&gt;
        &lt;etl:column name=&quot;unit_price&quot; type=&quot;decimal&quot; /&gt;
&lt;/etl:schema&gt;

&lt;etl:pipe id=&quot;mapperOutput&quot; /&gt;
&lt;etl:mapper id=&quot;mapper&quot; name=&quot;Mapper&quot;&gt;
        &lt;etl:input ref=&quot;input&quot; /&gt;
        &lt;etl:inputSchema ref=&quot;giantBikesSchema&quot; /&gt;
        &lt;etl:output ref=&quot;mapperOutput&quot; /&gt;
        &lt;etl:outputSchema ref=&quot;mtbSchema&quot; /&gt;
        &lt;etl:mappings&gt;
                &lt;etl:mapping&gt;
                        &lt;etl:from&gt;
                                &lt;etl:column name=&quot;name&quot; type=&quot;string&quot; /&gt;
                        &lt;/etl:from&gt;
                        &lt;etl:to&gt;
                                &lt;etl:column name=&quot;model_name&quot; type=&quot;string&quot; /&gt;
                        &lt;/etl:to&gt;
                &lt;/etl:mapping&gt;
                &lt;etl:mapping&gt;
                        &lt;etl:from&gt;
                                &lt;etl:column name=&quot;bike_number&quot; type=&quot;integer&quot; /&gt;
                        &lt;/etl:from&gt;
                        &lt;etl:to&gt;
                                &lt;etl:column name=&quot;model_number&quot; type=&quot;string&quot; /&gt;
                        &lt;/etl:to&gt;
                &lt;/etl:mapping&gt;
                &lt;etl:mapping&gt;
                        &lt;etl:from&gt;
                                &lt;etl:column name=&quot;year&quot; type=&quot;integer&quot; /&gt;
                        &lt;/etl:from&gt;
                        &lt;etl:to&gt;
                                &lt;etl:column name=&quot;model_year&quot; type=&quot;integer&quot; /&gt;
                        &lt;/etl:to&gt;
                &lt;/etl:mapping&gt;
                &lt;etl:mapping&gt;
                        &lt;etl:from&gt;
                                &lt;etl:column name=&quot;cost&quot; type=&quot;decimal&quot; /&gt;
                        &lt;/etl:from&gt;
                        &lt;etl:to&gt;
                                &lt;etl:column name=&quot;unit_price&quot; type=&quot;decimal&quot; /&gt;
                        &lt;/etl:to&gt;
                &lt;/etl:mapping&gt;
        &lt;/etl:mappings&gt;
&lt;/etl:mapper&gt;
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">etl:mappings</span></code> element allows for explicit mappings between input and output columns using the <code class="docutils literal"><span class="pre">etl:from</span></code> and <code class="docutils literal"><span class="pre">etl:to</span></code> elements. With this form, the column names do not need to match and type conversion is still supported.</p>
</div>
<div class="section" id="restful-consumer">
<h3>RESTful Consumer<a class="headerlink" href="#restful-consumer" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="restful-input">
<h3>RESTful Input<a class="headerlink" href="#restful-input" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="restful-lookup">
<h3>RESTful Lookup<a class="headerlink" href="#restful-lookup" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="sort">
<h3>Sort<a class="headerlink" href="#sort" title="Permalink to this headline">¶</a></h3>
<p>The sort filter sorts its input records according to a comparator. The sorted output is only written after all records have been read from its input. Consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;input&quot; /&gt;
&lt;etl:pipe id=&quot;output&quot; /&gt;
&lt;etl:sort id=&quot;sort&quot; name=&quot;Test Sort&quot;&gt;
        &lt;etl:input ref=&quot;input&quot; /&gt;
        &lt;etl:output ref=&quot;output&quot; /&gt;
        &lt;etl:comparator&gt;
                &lt;etl:column name=&quot;Name&quot; type=&quot;string&quot; /&gt;
        &lt;/etl:comparator&gt;
&lt;/etl:sort&gt;
</pre></div>
</div>
<p>The records read from the input (<code class="docutils literal"><span class="pre">ref=&quot;input&quot;</span></code>) are held in memory by the sort filter until it is ready to sort. Then the records are sorted using the comparator. In this case, the comparator orders the records by the <code class="docutils literal"><span class="pre">Name</span></code> column of the input records.</p>
<p>The sort filter also supports arbitrary comparators using Spring Beans:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;input&quot; /&gt;
&lt;etl:pipe id=&quot;output&quot; /&gt;
&lt;etl:sort id=&quot;sortWithBean&quot; name=&quot;Test Sort&quot;&gt;
        &lt;etl:input ref=&quot;input&quot; /&gt;
        &lt;etl:output ref=&quot;output&quot; /&gt;
        &lt;etl:comparator&gt;
                &lt;bean class=&quot;com.surgingsystems.etl.filter.SortFilterTest.TwoColumnComparator&quot;&gt;
                        &lt;property name=&quot;column1&quot;&gt;
                                &lt;etl:column name=&quot;Name&quot; type=&quot;string&quot; /&gt;
                        &lt;/property&gt;
                        &lt;property name=&quot;column2&quot;&gt;
                                &lt;etl:column name=&quot;Price&quot; type=&quot;decimal&quot; /&gt;
                        &lt;/property&gt;
                &lt;/bean&gt;
        &lt;/etl:comparator&gt;
&lt;/etl:sort&gt;
</pre></div>
</div>
<p>In this example, the comparator is supplied by a Java class (<code class="docutils literal"><span class="pre">bean</span> <span class="pre">class=&quot;...&quot;</span></code>) that has two properties for columns.</p>
<p>Because the sort filter stores all of its records in memory before it sorts, large data sets may use more memory than desireable. The sorting of very large data sets may be more suited to other solutions. For example, if the records are stored in a database, reading the records in sorted order might be a more appropirate solution.</p>
</div>
<div class="section" id="transformer">
<h3>Transformer<a class="headerlink" href="#transformer" title="Permalink to this headline">¶</a></h3>
<p>The transformer filter may be the most powerful filter, but also the most complex. The transformer is like an enhanced copy filter: it supports a single input, but any number of outputs. The outputs may be controlled through conditions and expressions.</p>
<p>The transformer uses the <a class="reference external" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html">Spring SpEL</a> expression language for expressions. The SpEL expressions are compiled, so they should not incur a significant performance penalty.</p>
<p>Consider the following transformer example:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:pipe id=&quot;input&quot; /&gt;
&lt;etl:pipe id=&quot;output1&quot; /&gt;
&lt;etl:pipe id=&quot;output2&quot; /&gt;
&lt;etl:pipe id=&quot;output3&quot; /&gt;

&lt;etl:transformer id=&quot;validatingTransformer&quot; name=&quot;Validating Transformer&quot;&gt;
        &lt;etl:input ref=&quot;input&quot; /&gt;
        &lt;etl:variable name=&quot;lastName&quot;&gt;&#39;&#39;&lt;/etl:variable&gt;
        &lt;etl:variable name=&quot;orderingProblem&quot;&gt;false&lt;/etl:variable&gt;
        &lt;etl:variable name=&quot;orderingProblemCount&quot;&gt;0&lt;/etl:variable&gt;
        &lt;etl:expression&gt;#orderingProblem = #lastName &gt; #inputRecord.Name&lt;/etl:expression&gt;
        &lt;etl:expression&gt;#orderingProblemCount = #orderingProblemCount + (#orderingProblem ? 1 : 0)&lt;/etl:expression&gt;
        &lt;etl:expression&gt;#lastName = #inputRecord.Name&lt;/etl:expression&gt;
        &lt;etl:config outputName=&quot;transformerOutput&quot; recordName=&quot;outputRecord&quot;&gt;
                &lt;etl:output ref=&quot;output1&quot; /&gt;
                &lt;etl:outputSchema ref=&quot;inputSchema&quot; /&gt;
                &lt;etl:outputCondition&gt;!#orderingProblem&lt;/etl:outputCondition&gt;
                &lt;etl:expression&gt;#outputRecord.Name = #inputRecord.Name&lt;/etl:expression&gt;
                &lt;etl:expression&gt;#outputRecord.Count = #inputRecord.Count&lt;/etl:expression&gt;
                &lt;etl:expression&gt;#outputRecord.Price = #inputRecord.Price&lt;/etl:expression&gt;
        &lt;/etl:config&gt;
        &lt;etl:config outputName=&quot;transformerOrderOutput&quot; recordName=&quot;invalidRecord&quot;&gt;
                &lt;etl:output ref=&quot;output2&quot; /&gt;
                &lt;etl:outputSchema ref=&quot;inputSchema&quot; /&gt;
                &lt;etl:outputCondition&gt;#orderingProblem&lt;/etl:outputCondition&gt;
                &lt;etl:expression&gt;#invalidRecord.Name = #inputRecord.Name&lt;/etl:expression&gt;
                &lt;etl:expression&gt;#invalidRecord.Count = #inputRecord.Count&lt;/etl:expression&gt;
                &lt;etl:expression&gt;#invalidRecord.Price = #inputRecord.Price&lt;/etl:expression&gt;
        &lt;/etl:config&gt;
        &lt;etl:config outputName=&quot;transformerOrderCountOutput&quot; recordName=&quot;invalidCountRecord&quot;&gt;
                &lt;etl:output ref=&quot;output3&quot; /&gt;
                &lt;etl:outputSchema ref=&quot;countSchema&quot; /&gt;
                &lt;etl:outputCondition&gt;#input.complete&lt;/etl:outputCondition&gt;
                &lt;etl:expression&gt;#invalidCountRecord.Count = #orderingProblemCount&lt;/etl:expression&gt;
        &lt;/etl:config&gt;
&lt;/etl:transformer&gt;
</pre></div>
</div>
<p>The first elements are pipes: one input (<code class="docutils literal"><span class="pre">id=&quot;input&quot;</span></code>) and some outputs (<code class="docutils literal"><span class="pre">id=&quot;output1&quot;</span></code>, <code class="docutils literal"><span class="pre">id=&quot;output2&quot;</span></code>, <code class="docutils literal"><span class="pre">id=&quot;output3&quot;</span></code>) that will be outputs from the transformer.</p>
<p>Next, the transformer is declared (<code class="docutils literal"><span class="pre">id=&quot;transformer&quot;</span></code>).</p>
<p>The first element of the transformer is its single input:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:input ref=&quot;input&quot; /&gt;
</pre></div>
</div>
<p>Next is a set of variables. The variables may be intialized to any constant value. The initialization of the variables occurs before any records have been processed. The values of previously declared variables or input records are not available for initializiation. The variables may be used in the output configuration for both output conditions and expressions.</p>
<p>The variables are followed by a set of expressions. The expressions are executed for each input record processed by the filter. The following expression sets the <code class="docutils literal"><span class="pre">orderingProblem</span></code> boolean value to true or false, depending on if the value of <code class="docutils literal"><span class="pre">lastName</span></code> is alphanumerically greater than the value of the <code class="docutils literal"><span class="pre">Name</span></code> column on the current input record:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:expression&gt;#orderingProblem = #lastName &gt; #inputRecord.Name&lt;/etl:expression&gt;
</pre></div>
</div>
<p>This means that if, for example, <code class="docutils literal"><span class="pre">lastName</span></code> is &#8220;Mojo&#8221; and the value of <code class="docutils literal"><span class="pre">inputRecord.Name</span></code> is &#8220;Bronson&#8221;, <code class="docutils literal"><span class="pre">lastName</span></code> will be set to &#8220;true&#8221; because &#8220;M&#8221; comes after &#8220;B&#8221; in the alphabet.</p>
<p>There are two forms for accessing a column on a record. One is using the &#8220;dot&#8221; notation as above: <code class="docutils literal"><span class="pre">inputRecord.Name</span></code>. The name of the record is before the dot and the column name is after the dot. An alternative is to use brackets: &#8220;[]&#8221;. This is expecially useful if the column name contains spaces. In the following example, the column name is &#8220;Column Name with Spaces&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:expression&gt;#inputRecord[&quot;Column Name with Spaces&quot;] = &quot;A useful value&quot;&lt;/etl:expression&gt;
</pre></div>
</div>
<p>Next in the example is a set of &#8220;output configurations&#8221;. These define the outputs of the transformer. Each configuration (<code class="docutils literal"><span class="pre">etl:config</span></code>) has two attributes. First is the <code class="docutils literal"><span class="pre">outputName</span></code>, which defines a variable for the output pipe used by the configuration. This variable may be used in expressions. Second is the <code class="docutils literal"><span class="pre">recordName</span></code>, which defines a variable for the record that will be output for that configuration. In this example, the <code class="docutils literal"><span class="pre">outputName</span></code> is not being used, but the <code class="docutils literal"><span class="pre">recordName</span></code> is used in each configuration:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:expression&gt;#outputRecord.Count = #inputRecord.Count&lt;/etl:expression&gt;
</pre></div>
</div>
<p>This expression sets the value of the <code class="docutils literal"><span class="pre">Count</span></code> column on the <code class="docutils literal"><span class="pre">outputRecord</span></code> to twice the value of the <code class="docutils literal"><span class="pre">Count</span></code> column on the <code class="docutils literal"><span class="pre">inputRecord</span></code>. The <code class="docutils literal"><span class="pre">inputRecord</span></code> is an implicit variable available to all expressions, capturing the current input record of the filter.</p>
<p>The output condition (<code class="docutils literal"><span class="pre">etl:outputCondition</span></code>) element controls the output of a configuration. If the value of the expression is true, the record is written to the output. Otherwise, no record is written. In this example, the <code class="docutils literal"><span class="pre">transformerOutput</span></code> and <code class="docutils literal"><span class="pre">transformerOrderOutput</span></code> are written in opposite conditions: if there is no ordering problem, a record is written to the former, otherwise a record is written to the latter.</p>
<p>Another variable is the <code class="docutils literal"><span class="pre">input</span></code> variable: it represents the input pipe for the filter and can likewise be used in expressions. In this example, the third output configuration (<code class="docutils literal"><span class="pre">outputName=&quot;transformerOrderCountOutput&quot;</span></code>) has a condition on the input being complete:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;etl:outputCondition&gt;#input.complete&lt;/etl:outputCondition&gt;
</pre></div>
</div>
<p>The count of out of order records is written to this output when all records have been read from the input. In this way a transformer may act as an aggregator filter.</p>
<p>While the transformer is very powerful, it can also be very complex. Designs using simpler filters are easier to understand. Consider the transformer to be a special purpose filter when no other filter will do.</p>
</div>
<div class="section" id="xml-file-reader">
<h3>XML File Reader<a class="headerlink" href="#xml-file-reader" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Filters</a><ul>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#filter-reference">Filter Reference</a><ul>
<li><a class="reference internal" href="#aggregator">Aggregator</a></li>
<li><a class="reference internal" href="#copy">Copy</a></li>
<li><a class="reference internal" href="#database-lookup">Database Lookup</a></li>
<li><a class="reference internal" href="#database-reader">Database Reader</a></li>
<li><a class="reference internal" href="#database-writer">Database Writer</a></li>
<li><a class="reference internal" href="#file-reader">File Reader</a></li>
<li><a class="reference internal" href="#file-writer">File Writer</a></li>
<li><a class="reference internal" href="#funnel">Funnel</a></li>
<li><a class="reference internal" href="#join">Join</a></li>
<li><a class="reference internal" href="#mapper">Mapper</a></li>
<li><a class="reference internal" href="#restful-consumer">RESTful Consumer</a></li>
<li><a class="reference internal" href="#restful-input">RESTful Input</a></li>
<li><a class="reference internal" href="#restful-lookup">RESTful Lookup</a></li>
<li><a class="reference internal" href="#sort">Sort</a></li>
<li><a class="reference internal" href="#transformer">Transformer</a></li>
<li><a class="reference internal" href="#xml-file-reader">XML File Reader</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="overview.html"
                        title="previous chapter">Current State</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="testing.html"
                        title="next chapter">Testing</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/filters.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="testing.html" title="Testing"
             >next</a> |</li>
        <li class="right" >
          <a href="overview.html" title="Current State"
             >previous</a> |</li>
        <li><a href="index.html">Pneumatic.IO 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Kevin Lewis.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3b2.
    </div>
  </body>
</html>